1) In bubble sort the time complexity is T(n)=O(n^2)  ( Worst case)., we create an unsorted  array., and use 2 for loops(nested loops) ., 1st loop  :: to push the large element to last index., 2nd for loop:: to make multiple comparisions and  swap operations  bwn two succesive adjacent elements!! (Here we sort elements from last index!!!)   (a[j],a[j+1],a[i] ,temp)

2) Selection sort:: the time complexity is T(n)=O(n^2) ., here also we create an array function to create an array(unsorted array)., In main method we insert array elements and call the function.., WE use 2 for loops ., 1st for loop : it  intially fixes the first element of first index as smaller and stored in var ,agaiin we create 2nd loop (runs from 2nd index element coz we already fixed 1st element) he we do operation of comparing from 2nd index element with smaller element i.e stored in var  j=s (a[i]=s>> temp=a[s], a[i]=a[s], a[s]=temp)... Sorting takes place from starting index

3) Insertiion sort:: the time complexity is T(n)=O(n^2) in worst case ., and in best/avg case T(n)=O(n)., Even in insertion sort we consider an unsorted array, here we consider only 1 for loop (to fix the  current index position), Let i be the  1st var, and also consider 2nd var situated just before 1st var.. We will compare a[j] and a[j+1] values if a[j] is greater then perform shifting operation.. , here we won't apply swap operation., we push the larger element to forward and move the smaller val to temp and decrement the j pointer., i.e the smaller val a[j+1] will be placed in current indexed var. { i)Initially we create 2 pointers(i,j) ., i =1st index, j =i-1 index(0th index) ., { here let a[j] > a[j+1] >> first we decrement the j pointer(j--) then push a[j+1] to backward.. then increment i, which is already presented in for loop} here i pointer is used to move forward, j pointer moves backward making space for smaller elements} ( 1.compare (if gretaer) 2. decrement j 3. shift elements 4. increment i)

4) Merge sort:: ( Merge sort is based on Diivide and conquer technique)., here we create an unsorted array (arr), and consider indices of lower (l) and higher (h) check the condition ., (l<r) then find the mid valued index., then for dividing the arrays into 2 parts find the size of 2 arrays, segregate them as from( arr,l,mid) .. (arr,mid+1,h) .. find the sizes , 2 for loops create i,j pointers for 2 arrays.. check the comdition for the elements of left and right arrays ., again put them in one merged array.
             
5)Quick sort:: ( Quick sort is based on the recursive divide and conquer technique) here we consider few elements:: pivot (fixed indexed element) , 1st i pointer, 2nd j pointer., > If my pivot is in last index  then 1st pointer i  will be in -1 position, second pointer j in 0th position , compare with pivot , if greater increment i and swap , if j and pivot comes together., swap pivot and a[i+1]., 
if pivot is in first position take 1st pointer in 1st index and 2nd pointer in last indexand compare with pivot then swap.
